"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .document_status import DocumentStatus
from agentset.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from agentset.utils import get_discriminator, validate_const
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from pydantic.functional_validators import AfterValidator
from typing import Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class DocumentWebhookEventSourceYoutubeVideoTypedDict(TypedDict):
    video_id: str
    r"""The ID of the youtube video."""
    type: Literal["YOUTUBE_VIDEO"]
    duration: NotRequired[float]
    r"""The duration of the youtube video in seconds."""


class DocumentWebhookEventSourceYoutubeVideo(BaseModel):
    video_id: Annotated[str, pydantic.Field(alias="videoId")]
    r"""The ID of the youtube video."""

    TYPE: Annotated[
        Annotated[
            Literal["YOUTUBE_VIDEO"], AfterValidator(validate_const("YOUTUBE_VIDEO"))
        ],
        pydantic.Field(alias="type"),
    ] = "YOUTUBE_VIDEO"

    duration: Optional[float] = None
    r"""The duration of the youtube video in seconds."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["duration"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class DocumentWebhookEventSourceCrawledPageTypedDict(TypedDict):
    type: Literal["CRAWLED_PAGE"]
    title: NotRequired[str]
    r"""The title of the crawled page."""
    description: NotRequired[str]
    r"""The description of the crawled page."""
    language: NotRequired[str]
    r"""The language of the crawled page."""


class DocumentWebhookEventSourceCrawledPage(BaseModel):
    TYPE: Annotated[
        Annotated[
            Literal["CRAWLED_PAGE"], AfterValidator(validate_const("CRAWLED_PAGE"))
        ],
        pydantic.Field(alias="type"),
    ] = "CRAWLED_PAGE"

    title: Optional[str] = None
    r"""The title of the crawled page."""

    description: Optional[str] = None
    r"""The description of the crawled page."""

    language: Optional[str] = None
    r"""The language of the crawled page."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["title", "description", "language"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class DocumentWebhookEventSourceManagedFileTypedDict(TypedDict):
    key: str
    r"""The key of the managed file to ingest."""
    type: Literal["MANAGED_FILE"]


class DocumentWebhookEventSourceManagedFile(BaseModel):
    key: str
    r"""The key of the managed file to ingest."""

    TYPE: Annotated[
        Annotated[
            Literal["MANAGED_FILE"], AfterValidator(validate_const("MANAGED_FILE"))
        ],
        pydantic.Field(alias="type"),
    ] = "MANAGED_FILE"


class DocumentWebhookEventSourceFileTypedDict(TypedDict):
    file_url: str
    r"""The URL of the file to ingest."""
    type: Literal["FILE"]


class DocumentWebhookEventSourceFile(BaseModel):
    file_url: Annotated[str, pydantic.Field(alias="fileUrl")]
    r"""The URL of the file to ingest."""

    TYPE: Annotated[
        Annotated[Literal["FILE"], AfterValidator(validate_const("FILE"))],
        pydantic.Field(alias="type"),
    ] = "FILE"


class DocumentWebhookEventSourceTextTypedDict(TypedDict):
    text: str
    r"""The text to ingest."""
    type: Literal["TEXT"]


class DocumentWebhookEventSourceText(BaseModel):
    text: str
    r"""The text to ingest."""

    TYPE: Annotated[
        Annotated[Literal["TEXT"], AfterValidator(validate_const("TEXT"))],
        pydantic.Field(alias="type"),
    ] = "TEXT"


DocumentWebhookEventSourceUnionTypedDict = TypeAliasType(
    "DocumentWebhookEventSourceUnionTypedDict",
    Union[
        DocumentWebhookEventSourceTextTypedDict,
        DocumentWebhookEventSourceFileTypedDict,
        DocumentWebhookEventSourceManagedFileTypedDict,
        DocumentWebhookEventSourceYoutubeVideoTypedDict,
        DocumentWebhookEventSourceCrawledPageTypedDict,
    ],
)
r"""Source configuration of the document."""


DocumentWebhookEventSourceUnion = Annotated[
    Union[
        Annotated[DocumentWebhookEventSourceText, Tag("TEXT")],
        Annotated[DocumentWebhookEventSourceFile, Tag("FILE")],
        Annotated[DocumentWebhookEventSourceManagedFile, Tag("MANAGED_FILE")],
        Annotated[DocumentWebhookEventSourceCrawledPage, Tag("CRAWLED_PAGE")],
        Annotated[DocumentWebhookEventSourceYoutubeVideo, Tag("YOUTUBE_VIDEO")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]
r"""Source configuration of the document."""


class DocumentWebhookEventDataTypedDict(TypedDict):
    id: str
    r"""Unique identifier for the document."""
    name: Nullable[str]
    r"""Name of the document."""
    namespace_id: str
    r"""ID of the namespace."""
    organization_id: str
    r"""ID of the organization."""
    status: DocumentStatus
    r"""The status of the document."""
    source: DocumentWebhookEventSourceUnionTypedDict
    r"""Source configuration of the document."""
    created_at: str
    r"""When the document was created."""
    updated_at: str
    r"""When the document was last updated."""
    total_characters: NotRequired[Nullable[float]]
    r"""Total characters in the document."""
    total_chunks: NotRequired[Nullable[float]]
    r"""Total chunks created from the document."""
    total_pages: NotRequired[Nullable[float]]
    r"""Total pages in the document."""
    error: NotRequired[Nullable[str]]
    r"""Error message if document processing failed."""


class DocumentWebhookEventData(BaseModel):
    id: str
    r"""Unique identifier for the document."""

    name: Nullable[str]
    r"""Name of the document."""

    namespace_id: Annotated[str, pydantic.Field(alias="namespaceId")]
    r"""ID of the namespace."""

    organization_id: Annotated[str, pydantic.Field(alias="organizationId")]
    r"""ID of the organization."""

    status: DocumentStatus
    r"""The status of the document."""

    source: DocumentWebhookEventSourceUnion
    r"""Source configuration of the document."""

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]
    r"""When the document was created."""

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]
    r"""When the document was last updated."""

    total_characters: Annotated[
        OptionalNullable[float], pydantic.Field(alias="totalCharacters")
    ] = UNSET
    r"""Total characters in the document."""

    total_chunks: Annotated[
        OptionalNullable[float], pydantic.Field(alias="totalChunks")
    ] = UNSET
    r"""Total chunks created from the document."""

    total_pages: Annotated[
        OptionalNullable[float], pydantic.Field(alias="totalPages")
    ] = UNSET
    r"""Total pages in the document."""

    error: OptionalNullable[str] = UNSET
    r"""Error message if document processing failed."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["totalCharacters", "totalChunks", "totalPages", "error"])
        nullable_fields = set(
            ["name", "totalCharacters", "totalChunks", "totalPages", "error"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class DocumentWebhookEventTypedDict(TypedDict):
    r"""Triggered when a document is queued, processed, ready, or deleted."""

    id: str
    created_at: str
    data: DocumentWebhookEventDataTypedDict
    event: Literal["document.queued"]


class DocumentWebhookEvent(BaseModel):
    r"""Triggered when a document is queued, processed, ready, or deleted."""

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    data: DocumentWebhookEventData

    EVENT: Annotated[
        Annotated[
            Literal["document.queued"],
            AfterValidator(validate_const("document.queued")),
        ],
        pydantic.Field(alias="event"),
    ] = "document.queued"
